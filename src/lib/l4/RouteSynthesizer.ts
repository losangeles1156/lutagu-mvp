/**
 * Route Synthesizer (The "Experience Layer")
 * 
 * Bridges the gap between L4 Physical Routes (Rails) and L3 User Experience (Pain).
 * 
 * Responsibilities:
 * 1. Analyze RouteOptions generated by AlgorithmProvider.
 * 2. Identify "Transfer Moments" (e.g., Change lines at Ueno).
 * 3. Zoom into L3 Topology (via TPICalculator) to estimate physical/mental cost.
 * 4. Apply GEM Intent Tags (e.g., LUGGAGE -> amplify resistance).
 * 5. Re-score and re-rank routes.
 */

import { RouteOption } from './types/RoutingTypes';
import { TPICalculator } from './TPICalculator';
import { L1NodeProfile } from './types/L1Profile';
import { L3GraphBuilder } from './L3GraphBuilder';

import { L3StationGraph } from './types/L3Topology';

// Mock mapping of Railway+Station to specific L3 Nodes
// In a real system, this comes from the database
const PLATFORM_MAP: Record<string, string> = {
    // Ueno - Ginza Line
    "odpt.Station:TokyoMetro.Ginza.Ueno": "Ueno.Platform.Ginza",
    // Ueno - Hibiya Line
    "odpt.Station:TokyoMetro.Hibiya.Ueno": "Ueno.Platform.Hibiya",
    // Ueno - JR Yamanote
    "odpt.Station:JR-East.Yamanote.Ueno": "Ueno.Platform.1", // Simplified
};

export class RouteSynthesizer {

    /**
     * Synthesize "Experience Scores" for raw physical routes.
     * @param routes Raw routes from AlgorithmProvider
     * @param profile User's Contextual Profile (with GEM Tags)
     */
    static async synthesize(routes: RouteOption[], profile: L1NodeProfile, isHoliday: boolean = false): Promise<RouteOption[]> {
        console.log(`[RouteSynthesizer] Analyzing ${routes.length} routes. Holiday: ${isHoliday}, Intent: ${profile.intent.capabilities.join(', ')}`);

        // Phase 6 Optimization: Batch Load Graphs
        // Identify unique stations involved in transfers
        const stationsToLoad = new Set<string>();
        // Hardcoded for MVP: Ueno is the only one we have data for
        stationsToLoad.add("odpt.Station:JR-East.Yamanote.Ueno");

        // Load Graphs Map
        const graphMap = new Map<string, L3StationGraph>();
        for (const stationId of stationsToLoad) {
            // In production, this would be a parallel fetch Promise.all
            // For MVP, we load Ueno (mock)
            if (stationId.includes("Ueno")) {
                graphMap.set(stationId, L3GraphBuilder.buildUenoGraph());
            }
        }

        const synthesized = await Promise.all(routes.map(async (route) => {
            let totalPainScore = 0;
            const transfers: any[] = [];

            // 1. Scan for Transfers
            for (let i = 0; i < route.steps.length - 1; i++) {
                const step = route.steps[i];
                const nextStep = route.steps[i + 1];

                if (step.kind === 'transfer') {
                    const prevTrain = route.steps[i - 1];
                    const nextTrain = route.steps[i + 1];

                    if (prevTrain?.kind === 'train' && nextTrain?.kind === 'train') {
                        // Hardcoded Check for Ueno Transfer
                        const isUenoTransfer = (
                            (prevTrain.text.includes('Ueno') || prevTrain.text.includes('上野')) ||
                            (nextTrain.text.includes('Ueno') || nextTrain.text.includes('上野'))
                        );

                        if (isUenoTransfer) {
                            // 2. Calculate TPI for Ueno using PRE-LOADED graph
                            const graph = graphMap.get("odpt.Station:JR-East.Yamanote.Ueno");
                            if (graph) {
                                const painCheck = this.calculateTransferPain(graph, profile, isHoliday);
                                totalPainScore += painCheck.score;
                                transfers.push({ station: 'Ueno', score: painCheck.score, notes: painCheck.reasons });
                            }
                        }
                    }
                }
            }

            // 3. Score Fusion: Time + Pain
            const timeScore = route.duration || 0;
            const finalScore = timeScore + totalPainScore;

            // [Phase 8.2] Semantic Reasoning Insights
            const insights: Array<{ type: 'pro' | 'con' | 'warning', text: string, icon?: string }> = [];

            // Insight: Crowd Avoidance
            if (totalPainScore < 10 && profile.intent.capabilities.includes('CROWD_HI')) {
                insights.push({ type: 'pro', text: 'Avoided High Traffic', icon: 'UserCheck' });
            }

            // Insight: Luggage Friendly
            if (profile.intent.capabilities.includes('LUGGAGE')) {
                if (totalPainScore < 20) {
                    insights.push({ type: 'pro', text: 'Luggage Friendly Route', icon: 'Briefcase' });
                } else {
                    insights.push({ type: 'warning', text: 'Contains Stairs', icon: 'AlertTriangle' });
                }
            }

            // Insight: Transfers
            transfers.forEach(t => {
                if (t.score > 15) {
                    insights.push({ type: 'con', text: `Difficult Transfer at ${t.station}`, icon: 'GitGraph' });
                }
            });

            return {
                ...route,
                _score: finalScore,
                _debug_pain: totalPainScore,
                _debug_notes: transfers,
                insights
            };
        }));

        // 4. Re-rank (Lower score is better)
        return synthesized.sort((a: any, b: any) => a._score - b._score);
    }

    /**
     * Calculate Pain Index for a transfer using L3 Graph.
     * Uses pre-loaded graph to avoid redundant fetches.
     */
    private static calculateTransferPain(graph: L3StationGraph, profile: L1NodeProfile, isHoliday: boolean): { score: number, reasons: string[] } {
        // Find High-Resistance Edges (Stairs, Narrow, etc.)
        // This is now purely CPU bound (graph traversal), no I/O.

        let pain = 0;
        const reasons: string[] = [];

        const hasLuggage = profile.intent.capabilities.includes('LUGGAGE');
        const hasStroller = profile.intent.capabilities.includes('STROLLER');

        // Analyze Edges in Graph
        graph.edges.forEach(edge => {

            // GEM Visual Tags & Resistance
            if (edge.tags.includes('stairs')) {
                let cost = 10;
                if (hasLuggage) {
                    cost *= 3.0; // Huge penalty
                    reasons.push('Avoid Stairs (Luggage)');
                } else if (hasStroller) {
                    cost *= 5.0; // Blocker
                    reasons.push('Avoid Stairs (Stroller)');
                }
            }

            if (edge.tags.includes('NARROW')) {
                if (hasLuggage) {
                    pain += 20;
                    reasons.push('Narrow Corridor');
                }

            }

            // Holiday Crowd Penalty (Global)
            // If holiday, assume major hubs are crowded
            if (isHoliday && (graph.stationId.includes("Ueno") || graph.stationId.includes("Tokyo"))) {
                pain += 15;
                reasons.push('Holiday Crowds (High)');
            }
        });

        // Normalize
        if (hasLuggage && reasons.length > 0) {
            pain += 30;
        }

        return { score: pain, reasons: [...new Set(reasons)] };
    }
}
