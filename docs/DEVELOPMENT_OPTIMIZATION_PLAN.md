# LUTAGU AI æ··åˆæ¶æ§‹ç³»çµ± - é–‹ç™¼å„ªåŒ–å·¥ä½œè¨ˆåŠƒ

> **ç‰ˆæœ¬**: 1.0
> **å»ºç«‹æ—¥æœŸ**: 2025-01-09
> **ç›®æ¨™**: å®Œå–„ AI æ··åˆæ¶æ§‹ç³»çµ±ï¼Œæå‡ ODPT Challenge 2025 ç«¶è³½ç«¶çˆ­åŠ›

---

## ğŸ“‹ è¨ˆåŠƒç¸½è¦½

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        é–‹ç™¼å„ªåŒ–å·¥ä½œéšæ®µç¸½è¦½                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Phase 1 (çŸ­æœŸ)     â”‚  Phase 2 (ä¸­æœŸ)      â”‚  Phase 3 (é•·æœŸ)            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚
â”‚  â€¢ TPI/CDR æ•´åˆå•Ÿç”¨ â”‚  â€¢ éŒ¯èª¤ç›£æ§ç³»çµ±      â”‚  â€¢ ç”¨æˆ¶åé¥‹å­¸ç¿’ç³»çµ±         â”‚
â”‚  â€¢ TOP 10 ç«™é»æ•¸æ“š  â”‚  â€¢ Amenities æ•¸æ“š    â”‚  â€¢ A/B æ¸¬è©¦æ¡†æ¶             â”‚
â”‚  â€¢ åŸºç¤å–®å…ƒæ¸¬è©¦     â”‚  â€¢ å®Œæ•´æ¸¬è©¦å¥—ä»¶      â”‚  â€¢ å¤šæ•¸æ“šæºæ•´åˆ             â”‚
â”‚                     â”‚  â€¢ Deep Link æ•´åˆ    â”‚  â€¢ æ¬Šé‡è‡ªå‹•èª¿å„ª             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é ä¼°å·¥æœŸ: 5å¤©      â”‚  é ä¼°å·¥æœŸ: 10å¤©      â”‚  é ä¼°å·¥æœŸ: æŒçºŒè¿­ä»£          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ Phase 1: æ ¸å¿ƒåŠŸèƒ½æ•´åˆ (çŸ­æœŸ - 5å€‹å·¥ä½œå¤©)

### 1.1 TPI/CDR è¨ˆç®—æ•´åˆè‡³ HybridEngine

**ç›®æ¨™**: å°‡è¨­è¨ˆå®Œå–„çš„ TPI/CDR ç®—æ³•å¯¦éš›æ•´åˆåˆ°è·¯ç·šæ¨è–¦æµç¨‹

**æª”æ¡ˆè®Šæ›´**:
- `src/lib/l4/HybridEngine.ts`
- `src/lib/l4/reasoning/TransferPainIndex.ts` (æ–°å»º)
- `src/lib/l4/reasoning/CascadeDelayRisk.ts` (æ–°å»º)

#### ä»»å‹™ 1.1.1: å¯¦ç¾ TPI è¨ˆç®—å™¨

```typescript
// src/lib/l4/reasoning/TransferPainIndex.ts

import {
  TPIInput,
  TPIResult,
  TPIWeights,
  DEFAULT_REASONING_CONFIG
} from './types';

export class TransferPainIndexCalculator {
  private weights: TPIWeights;

  constructor(weights?: TPIWeights) {
    this.weights = weights || DEFAULT_REASONING_CONFIG.tpiWeights;
  }

  /**
   * è¨ˆç®—æ°´å¹³è·é›¢åˆ†æ•¸
   */
  private calcDistanceScore(meters: number): number {
    if (meters <= 100) return 0;
    if (meters <= 200) return 20;
    if (meters <= 300) return 40;
    if (meters <= 500) return 60;
    if (meters <= 800) return 80;
    return 100;
  }

  /**
   * è¨ˆç®—å‚ç›´ç§»å‹•åˆ†æ•¸
   */
  private calcVerticalScore(
    floors: number,
    method: 'elevator' | 'escalator' | 'stairs' | 'mixed',
    hasLuggage: boolean
  ): number {
    const baseScore = Math.abs(floors) * 10;
    const methodMultiplier = {
      elevator: 0.3,
      escalator: 0.6,
      stairs: 1.0,
      mixed: 0.7
    };
    const luggageMultiplier = hasLuggage ? 1.5 : 1.0;
    return Math.min(100, baseScore * methodMultiplier[method] * luggageMultiplier);
  }

  /**
   * è¨ˆç®—å‹•ç·šè¤‡é›œåº¦åˆ†æ•¸
   */
  private calcComplexityScore(complexity: TPIInput['transfer']['complexity']): number {
    let score = 0;
    score += complexity.turnCount * 5;
    score += (4 - complexity.signageClarity) * 15;
    score += Math.min(complexity.exitCount / 2, 20);
    score += complexity.underConstruction ? 25 : 0;
    return Math.min(100, score);
  }

  /**
   * è¨ˆç®—äººæ½®ä¿®æ­£åˆ†æ•¸
   */
  private calcCrowdScore(level: TPIInput['crowdLevel'], hasLuggage: boolean): number {
    const baseScores = {
      empty: 0,
      normal: 10,
      busy: 30,
      packed: 60,
      crush: 100
    };
    const luggageMultiplier = hasLuggage ? 1.5 : 1.0;
    return Math.min(100, baseScores[level] * luggageMultiplier);
  }

  /**
   * è¨ˆç®—ç”¨æˆ¶ç‹€æ…‹ä¿®æ­£
   */
  private calcUserModifier(accessibility: TPIInput['userAccessibilityNeeds']): number {
    let modifier = 0;
    if (accessibility.wheelchair) modifier += 40;
    if (accessibility.stroller) modifier += 30;
    if (accessibility.elderly) modifier += 20;
    if (accessibility.visualImpairment) modifier += 25;
    return Math.min(100, modifier);
  }

  /**
   * è¨ˆç®—å®Œæ•´ TPI
   */
  public calculate(input: TPIInput): TPIResult {
    const distance = this.calcDistanceScore(input.transfer.walkingDistanceMeters);
    const vertical = this.calcVerticalScore(
      input.transfer.floorDifference,
      input.transfer.verticalMethod,
      input.userHasLuggage
    );
    const complexity = this.calcComplexityScore(input.transfer.complexity);
    const crowd = this.calcCrowdScore(input.crowdLevel, input.userHasLuggage);
    const userModifier = this.calcUserModifier(input.userAccessibilityNeeds);

    const score = Math.min(100, Math.round(
      this.weights.distance * distance +
      this.weights.vertical * vertical +
      this.weights.complexity * complexity +
      this.weights.crowd * crowd +
      this.weights.userModifier * userModifier
    ));

    const level = this.getLevel(score);
    const recommendation = this.getRecommendation(level, input);

    return {
      score,
      level,
      breakdown: { distance, vertical, complexity, crowd, userModifier },
      recommendation
    };
  }

  private getLevel(score: number): TPIResult['level'] {
    if (score <= 20) return 'easy';
    if (score <= 40) return 'normal';
    if (score <= 60) return 'hard';
    if (score <= 80) return 'difficult';
    return 'extreme';
  }

  private getRecommendation(level: TPIResult['level'], input: TPIInput): string {
    const messages: Record<string, Record<TPIResult['level'], string>> = {
      zh: {
        easy: 'è½‰ä¹˜è¼•é¬†ï¼Œæ­£å¸¸è¡Œèµ°å³å¯',
        normal: `éœ€æ­¥è¡Œç´„ ${Math.ceil(input.transfer.walkingDistanceMeters / 80)} åˆ†é˜`,
        hard: 'è½‰ä¹˜è¼ƒç‚ºè¾›è‹¦ï¼Œå»ºè­°é ç•™å……è¶³æ™‚é–“',
        difficult: 'è½‰ä¹˜ç›¸ç•¶å›°é›£ï¼Œå¼·çƒˆå»ºè­°è€ƒæ…®æ›¿ä»£è·¯ç·š',
        extreme: 'è½‰ä¹˜æ¥µåº¦å›°é›£ï¼Œå»ºè­°æ”¹æ­è¨ˆç¨‹è»Šæˆ–é¸æ“‡å…¶ä»–è·¯ç·š'
      },
      en: {
        easy: 'Easy transfer, normal walking',
        normal: `About ${Math.ceil(input.transfer.walkingDistanceMeters / 80)} min walk`,
        hard: 'Moderate difficulty, allow extra time',
        difficult: 'Difficult transfer, consider alternatives',
        extreme: 'Extremely difficult, recommend taxi or different route'
      }
    };
    return messages.zh[level];
  }
}

export const tpiCalculator = new TransferPainIndexCalculator();
```

#### ä»»å‹™ 1.1.2: å¯¦ç¾ CDR è¨ˆç®—å™¨

```typescript
// src/lib/l4/reasoning/CascadeDelayRisk.ts

import {
  JourneyLeg,
  TransferWindow,
  CDRResult,
  RiskLevel,
  LastTrainRisk
} from './types';

export class CascadeDelayRiskCalculator {
  /**
   * è¨ˆç®—å–®æ¬¡è½‰ä¹˜æˆåŠŸç‡
   */
  private calcTransferSuccessRate(window: TransferWindow): number {
    const bufferMinutes =
      (window.nextDeparture.getTime() - window.scheduledArrival.getTime()) / 60000
      - window.transferTimeRequired;

    const effectiveBuffer = bufferMinutes - window.delayMinutes;

    if (effectiveBuffer >= 10) return 0.99;
    if (effectiveBuffer >= 5) return 0.90;
    if (effectiveBuffer >= 3) return 0.70;
    if (effectiveBuffer >= 1) return 0.40;
    if (effectiveBuffer >= 0) return 0.20;
    return 0.05;
  }

  /**
   * å–å¾—è½‰ä¹˜æ‰€éœ€æ™‚é–“ (åˆ†é˜)
   */
  private getTransferTime(stationId: string, fromLine: string, toLine: string): number {
    // TODO: å¾è³‡æ–™åº«æŸ¥è©¢å¯¦éš›è½‰ä¹˜æ™‚é–“
    // é è¨­å€¼ï¼šåŒç«™è½‰ä¹˜ 5 åˆ†é˜
    return 5;
  }

  /**
   * è¨ˆç®—é€£é–å»¶èª¤é¢¨éšª
   */
  public calculate(legs: JourneyLeg[]): CDRResult {
    if (legs.length === 0) {
      return {
        overallSuccessRate: 1.0,
        riskLevel: 'low',
        bottleneckLegIndex: -1,
        legSuccessRates: [],
        recommendation: 'ç„¡è½‰ä¹˜é¢¨éšª'
      };
    }

    let cumulativeDelay = 0;
    let overallSuccessRate = 1.0;
    let bottleneckLegIndex = -1;
    let minSuccessRate = 1.0;
    const legSuccessRates: number[] = [];

    for (let i = 0; i < legs.length - 1; i++) {
      const currentLeg = legs[i];
      const nextLeg = legs[i + 1];

      cumulativeDelay += currentLeg.currentDelayMinutes;

      const transferWindow: TransferWindow = {
        scheduledArrival: currentLeg.scheduledArrival,
        nextDeparture: nextLeg.scheduledDeparture,
        transferTimeRequired: this.getTransferTime(
          currentLeg.toStation,
          currentLeg.line,
          nextLeg.line
        ),
        delayMinutes: cumulativeDelay
      };

      const tsr = this.calcTransferSuccessRate(transferWindow);
      legSuccessRates.push(tsr);
      overallSuccessRate *= tsr;

      if (tsr < minSuccessRate) {
        minSuccessRate = tsr;
        bottleneckLegIndex = i;
      }
    }

    const riskLevel = this.getRiskLevel(overallSuccessRate);
    const bottleneckReason = bottleneckLegIndex >= 0
      ? `ç¬¬ ${bottleneckLegIndex + 1} æ®µè½‰ä¹˜é¢¨éšªæœ€é«˜ (${legs[bottleneckLegIndex].lineName})`
      : undefined;

    return {
      overallSuccessRate: Math.round(overallSuccessRate * 100) / 100,
      riskLevel,
      bottleneckLegIndex,
      bottleneckReason,
      legSuccessRates,
      recommendation: this.getRecommendation(riskLevel, bottleneckLegIndex, legs)
    };
  }

  private getRiskLevel(successRate: number): RiskLevel {
    if (successRate >= 0.8) return 'low';
    if (successRate >= 0.5) return 'medium';
    if (successRate >= 0.2) return 'high';
    return 'critical';
  }

  private getRecommendation(
    riskLevel: RiskLevel,
    bottleneckIndex: number,
    legs: JourneyLeg[]
  ): string {
    const recommendations: Record<RiskLevel, string> = {
      low: 'è½‰ä¹˜é¢¨éšªä½ï¼Œå¯æŒ‰åŸè¨ˆåŠƒè¡Œå‹•',
      medium: 'æœ‰ä¸€å®šé¢¨éšªï¼Œå»ºè­°æå‰å‡ºç™¼æˆ–æº–å‚™å‚™ç”¨è·¯ç·š',
      high: 'é¢¨éšªè¼ƒé«˜ï¼Œå¼·çƒˆå»ºè­°æ”¹èµ°æ›¿ä»£è·¯ç·š',
      critical: 'é¢¨éšªæ¥µé«˜ï¼Œå»ºè­°ç«‹å³æ”¹è®Šè¨ˆåŠƒæˆ–æ­ä¹˜è¨ˆç¨‹è»Š'
    };

    let message = recommendations[riskLevel];

    if (bottleneckIndex >= 0 && riskLevel !== 'low') {
      const leg = legs[bottleneckIndex];
      message += `ã€‚ç“¶é ¸åœ¨ ${leg.toStation} ç«™çš„è½‰ä¹˜`;
    }

    return message;
  }

  /**
   * è¨ˆç®—æœ«ç­è»Šé¢¨éšª
   */
  public calcLastTrainRisk(
    journey: JourneyLeg[],
    currentTime: Date,
    lastTrainTimes: Map<string, Date>
  ): LastTrainRisk {
    const missedLines: LastTrainRisk['missedLines'] = [];
    let earliestDeadline: Date | null = null;

    for (const leg of journey) {
      const lastTrain = lastTrainTimes.get(leg.line);
      if (!lastTrain) continue;

      const requiredArrival = new Date(lastTrain.getTime() - 10 * 60000);

      if (leg.scheduledArrival > requiredArrival) {
        missedLines.push({
          line: leg.line,
          lineName: leg.lineName,
          lastTrainTime: lastTrain,
          reason: `æœ«ç­è»Š ${lastTrain.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })}`
        });
      }

      const legDuration = leg.scheduledArrival.getTime() - leg.scheduledDeparture.getTime();
      const deadline = new Date(requiredArrival.getTime() - legDuration);

      if (!earliestDeadline || deadline < earliestDeadline) {
        earliestDeadline = deadline;
      }
    }

    return {
      hasRisk: missedLines.length > 0,
      missedLines,
      safeDepartureDeadline: earliestDeadline,
      alternativeOptions: missedLines.length > 0
        ? ['è¨ˆç¨‹è»Š (GO/JapanTaxi)', 'ç¶²å’–ä¼‘æ¯', 'è† å›Šæ—…é¤¨', '24å°æ™‚é¤å»³']
        : []
    };
  }
}

export const cdrCalculator = new CascadeDelayRiskCalculator();
```

#### ä»»å‹™ 1.1.3: æ•´åˆè‡³ HybridEngine

**ä¿®æ”¹æª”æ¡ˆ**: `src/lib/l4/HybridEngine.ts`

```typescript
// åœ¨ HybridEngine ä¸­æ–°å¢æ–¹æ³•

import { tpiCalculator } from './reasoning/TransferPainIndex';
import { cdrCalculator } from './reasoning/CascadeDelayRisk';
import { calcWaitValue } from './reasoning/WaitValueCoefficient';

// æ–°å¢è·¯ç·šè©•åˆ†æ–¹æ³•
private async scoreRoutes(
  routes: any[],
  context?: RequestContext,
  userPreferences?: UserPreferences
): Promise<ScoredRoute[]> {
  const scoredRoutes = await Promise.all(
    routes.map(async (route) => {
      // è¨ˆç®— TPI (å¦‚æœæœ‰è½‰ä¹˜)
      let totalTpi = 0;
      if (route.transfers?.length > 0) {
        for (const transfer of route.transfers) {
          const tpiInput = this.buildTPIInput(transfer, userPreferences);
          const tpiResult = tpiCalculator.calculate(tpiInput);
          totalTpi += tpiResult.score;
        }
        totalTpi = totalTpi / route.transfers.length;
      }

      // è¨ˆç®— CDR
      const cdrResult = cdrCalculator.calculate(route.legs || []);

      // è¨ˆç®—æ™‚é–“æ•ˆç‡
      const timeEfficiency = this.calcTimeEfficiency(route);

      // ç¶œåˆè©•åˆ†
      const compositeScore = (100 - totalTpi) * cdrResult.overallSuccessRate * timeEfficiency;

      return {
        route,
        tpiScore: totalTpi,
        cdrResult,
        timeEfficiency,
        compositeScore,
        isRecommended: false,
        reasoning: ''
      };
    })
  );

  // æ¨™è¨˜æœ€ä½³è·¯ç·š
  scoredRoutes.sort((a, b) => b.compositeScore - a.compositeScore);
  if (scoredRoutes.length > 0) {
    scoredRoutes[0].isRecommended = true;
    scoredRoutes[0].reasoning = this.generateRouteReasoning(scoredRoutes[0]);
  }

  return scoredRoutes;
}
```

---

### 1.2 TOP 10 å¤§ç«™è½‰ä¹˜æ•¸æ“šå¡«å……

**ç›®æ¨™**: å»ºç«‹æ ¸å¿ƒè»Šç«™çš„è½‰ä¹˜è³‡è¨Šæ•¸æ“š

**æª”æ¡ˆ**:
- `scripts/seed_station_transfers.ts` (æ–°å»º)
- `supabase/migrations/xxx_station_transfers_data.sql` (æ–°å»º)

#### ä»»å‹™ 1.2.1: å»ºç«‹ç¨®å­æ•¸æ“šè…³æœ¬

```typescript
// scripts/seed_station_transfers.ts

import { createClient } from '@supabase/supabase-js';

const STATION_TRANSFERS_DATA = [
  // æ±äº¬ç«™
  {
    from_station_id: 'odpt.Station:JR-East.ChuoRapid.Tokyo',
    from_line_id: 'odpt.Railway:JR-East.ChuoRapid',
    to_station_id: 'odpt.Station:JR-East.Keiyo.Tokyo',
    to_line_id: 'odpt.Railway:JR-East.Keiyo',
    walking_distance_meters: 500,
    floor_difference: -4,
    vertical_method: 'mixed',
    turn_count: 8,
    signage_clarity: 2,
    base_tpi: 85,
    peak_hour_multiplier: 1.3,
    expert_notes: {
      traps: ['åœ°ä¸‹é€šé“å¾ˆé•·ï¼Œå®¹æ˜“è¿·è·¯', 'äººæ½®å¤šæ™‚éœ€æ’éšŠç­‰é›»æ‰¶æ¢¯'],
      hacks: ['è·Ÿè‘—ã€Œäº¬è‘‰ç·šã€æŒ‡ç¤ºèµ°', 'å»ºè­°ä½¿ç”¨å…«é‡æ´²å—å£è½‰ä¹˜']
    }
  },
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Tokyo',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:TokyoMetro.Marunouchi.Tokyo',
    to_line_id: 'odpt.Railway:TokyoMetro.Marunouchi',
    walking_distance_meters: 150,
    floor_difference: -1,
    vertical_method: 'escalator',
    turn_count: 2,
    signage_clarity: 3,
    base_tpi: 20,
    peak_hour_multiplier: 1.1,
    expert_notes: {
      traps: [],
      hacks: ['ä¸¸ä¹‹å…§åœ°ä¸‹å‡ºå£ç›´çµï¼Œéå¸¸æ–¹ä¾¿']
    }
  },
  // æ–°å®¿ç«™
  {
    from_station_id: 'odpt.Station:JR-East.ChuoRapid.Shinjuku',
    from_line_id: 'odpt.Railway:JR-East.ChuoRapid',
    to_station_id: 'odpt.Station:Toei.Oedo.ShinjukuNishiguchi',
    to_line_id: 'odpt.Railway:Toei.Oedo',
    walking_distance_meters: 400,
    floor_difference: -6,
    vertical_method: 'mixed',
    turn_count: 5,
    signage_clarity: 2,
    base_tpi: 70,
    peak_hour_multiplier: 1.4,
    expert_notes: {
      traps: ['å¤§æ±Ÿæˆ¶ç·šæœˆå°å¾ˆæ·±', 'å‡ºå£è¶…é200å€‹å®¹æ˜“è¿·è·¯'],
      hacks: ['å»ºè­°å¾è¥¿å£å‡ºç«™', 'è·Ÿè‘—ã€Œéƒ½ç‡Ÿå¤§æ±Ÿæˆ¶ç·šã€æŒ‡ç¤º']
    }
  },
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Shinjuku',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:TokyoMetro.Marunouchi.Shinjuku',
    to_line_id: 'odpt.Railway:TokyoMetro.Marunouchi',
    walking_distance_meters: 200,
    floor_difference: -2,
    vertical_method: 'escalator',
    turn_count: 3,
    signage_clarity: 2,
    base_tpi: 45,
    peak_hour_multiplier: 1.3,
    expert_notes: {
      traps: ['äººæ½®æ“æ“ æ™‚éœ€æ’éšŠ'],
      hacks: ['å¾æ±å£æ–¹å‘è½‰ä¹˜è¼ƒå¿«']
    }
  },
  // æ¾€è°·ç«™
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Shibuya',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:TokyoMetro.Fukutoshin.Shibuya',
    to_line_id: 'odpt.Railway:TokyoMetro.Fukutoshin',
    walking_distance_meters: 350,
    floor_difference: -5,
    vertical_method: 'mixed',
    turn_count: 4,
    signage_clarity: 2,
    base_tpi: 65,
    peak_hour_multiplier: 1.4,
    expert_notes: {
      traps: ['ç«™é«”æ–½å·¥ä¸­ï¼Œå‹•ç·šç¶“å¸¸è®Šæ›´', 'æŒ‡æ¨™å¯èƒ½èˆ‡å¯¦éš›ä¸ç¬¦'],
      hacks: ['å‰¯éƒ½å¿ƒç·šåœ¨åœ°ä¸‹5æ¨“', 'å»ºè­°ä½¿ç”¨æ–°å—å£']
    }
  },
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Shibuya',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:TokyoMetro.Ginza.Shibuya',
    to_line_id: 'odpt.Railway:TokyoMetro.Ginza',
    walking_distance_meters: 250,
    floor_difference: -2,
    vertical_method: 'escalator',
    turn_count: 3,
    signage_clarity: 2,
    base_tpi: 50,
    peak_hour_multiplier: 1.3,
    expert_notes: {
      traps: ['æ–½å·¥å½±éŸ¿å‹•ç·š'],
      hacks: ['éŠ€åº§ç·šæœˆå°åœ¨3æ¨“ï¼ˆåœ°ä¸Šï¼‰']
    }
  },
  // æ± è¢‹ç«™
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Ikebukuro',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:TokyoMetro.Yurakucho.Ikebukuro',
    to_line_id: 'odpt.Railway:TokyoMetro.Yurakucho',
    walking_distance_meters: 300,
    floor_difference: -2,
    vertical_method: 'escalator',
    turn_count: 4,
    signage_clarity: 2,
    base_tpi: 50,
    peak_hour_multiplier: 1.2,
    expert_notes: {
      traps: ['æ±è¥¿å‡ºå£å®¹æ˜“ææ··'],
      hacks: ['æœ‰æ¨‚ç”ºç·šåœ¨è¥¿å£æ–¹å‘']
    }
  },
  // ä¸Šé‡ç«™
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Ueno',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:TokyoMetro.Ginza.Ueno',
    to_line_id: 'odpt.Railway:TokyoMetro.Ginza',
    walking_distance_meters: 200,
    floor_difference: -1,
    vertical_method: 'escalator',
    turn_count: 2,
    signage_clarity: 3,
    base_tpi: 30,
    peak_hour_multiplier: 1.1,
    expert_notes: {
      traps: [],
      hacks: ['å‹•ç·šæ¸…æ™°ï¼Œè·Ÿè‘—æŒ‡ç¤ºå³å¯']
    }
  },
  // ç§‹è‘‰åŸç«™
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Akihabara',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:TokyoMetro.Hibiya.Akihabara',
    to_line_id: 'odpt.Railway:TokyoMetro.Hibiya',
    walking_distance_meters: 150,
    floor_difference: -1,
    vertical_method: 'escalator',
    turn_count: 2,
    signage_clarity: 3,
    base_tpi: 25,
    peak_hour_multiplier: 1.1,
    expert_notes: {
      traps: [],
      hacks: ['é›»æ°£è¡—å£å‡ºç«™å¾Œå³å¯çœ‹åˆ°æ—¥æ¯”è°·ç·šå…¥å£']
    }
  },
  // å“å·ç«™
  {
    from_station_id: 'odpt.Station:JR-East.Yamanote.Shinagawa',
    from_line_id: 'odpt.Railway:JR-East.Yamanote',
    to_station_id: 'odpt.Station:Keikyu.Main.Shinagawa',
    to_line_id: 'odpt.Railway:Keikyu.Main',
    walking_distance_meters: 200,
    floor_difference: 0,
    vertical_method: 'escalator',
    turn_count: 2,
    signage_clarity: 3,
    base_tpi: 25,
    peak_hour_multiplier: 1.2,
    expert_notes: {
      traps: ['å‰å¾€ç¾½ç”°æ©Ÿå ´æ™‚è¦æ³¨æ„åˆ—è»Šç¨®åˆ¥'],
      hacks: ['äº¬æ€¥ç·šåœ¨JRæ”¹æœ­å¤–ï¼Œéœ€è¦å…ˆå‡ºç«™']
    }
  }
];

async function seedStationTransfers() {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );

  console.log('é–‹å§‹å¡«å……è»Šç«™è½‰ä¹˜æ•¸æ“š...');

  for (const transfer of STATION_TRANSFERS_DATA) {
    const { error } = await supabase
      .from('station_transfers')
      .upsert(transfer, {
        onConflict: 'from_station_id,from_line_id,to_station_id,to_line_id'
      });

    if (error) {
      console.error(`å¡«å……å¤±æ•—: ${transfer.from_station_id} â†’ ${transfer.to_station_id}`, error);
    } else {
      console.log(`âœ“ ${transfer.from_station_id} â†’ ${transfer.to_station_id}`);
    }
  }

  console.log('è»Šç«™è½‰ä¹˜æ•¸æ“šå¡«å……å®Œæˆï¼');
}

seedStationTransfers().catch(console.error);
```

---

### 1.3 åŸºç¤å–®å…ƒæ¸¬è©¦

**ç›®æ¨™**: å»ºç«‹ TPI/CDR/WVC çš„å–®å…ƒæ¸¬è©¦

**æª”æ¡ˆ**:
- `src/lib/l4/reasoning/__tests__/TransferPainIndex.test.ts`
- `src/lib/l4/reasoning/__tests__/CascadeDelayRisk.test.ts`
- `src/lib/l4/reasoning/__tests__/WaitValueCoefficient.test.ts`

#### ä»»å‹™ 1.3.1: TPI å–®å…ƒæ¸¬è©¦

```typescript
// src/lib/l4/reasoning/__tests__/TransferPainIndex.test.ts

import { tpiCalculator } from '../TransferPainIndex';
import { TPIInput } from '../types';

describe('TransferPainIndexCalculator', () => {
  const baseInput: TPIInput = {
    transfer: {
      fromStationId: 'test-from',
      fromLineId: 'test-line-a',
      toStationId: 'test-to',
      toLineId: 'test-line-b',
      walkingDistanceMeters: 200,
      floorDifference: 1,
      verticalMethod: 'escalator',
      complexity: {
        turnCount: 2,
        signageClarity: 3,
        exitCount: 4,
        underConstruction: false
      },
      baseTpi: 30,
      peakHourMultiplier: 1.0
    },
    crowdLevel: 'normal',
    userHasLuggage: false,
    userAccessibilityNeeds: {
      wheelchair: false,
      stroller: false,
      elderly: false,
      visualImpairment: false
    }
  };

  test('åŸºæœ¬è½‰ä¹˜æ‡‰è¿”å› easy ç­‰ç´š', () => {
    const result = tpiCalculator.calculate(baseInput);
    expect(result.level).toBe('easy');
    expect(result.score).toBeLessThanOrEqual(20);
  });

  test('æ±äº¬ç«™äº¬è‘‰ç·šè½‰ä¹˜æ‡‰è¿”å› extreme ç­‰ç´š', () => {
    const tokyoKeiyoInput: TPIInput = {
      ...baseInput,
      transfer: {
        ...baseInput.transfer,
        walkingDistanceMeters: 500,
        floorDifference: 4,
        verticalMethod: 'mixed',
        complexity: {
          turnCount: 8,
          signageClarity: 2,
          exitCount: 20,
          underConstruction: false
        }
      },
      crowdLevel: 'busy'
    };

    const result = tpiCalculator.calculate(tokyoKeiyoInput);
    expect(result.level).toBe('extreme');
    expect(result.score).toBeGreaterThan(80);
  });

  test('è¼ªæ¤…ç”¨æˆ¶æ‡‰å¤§å¹…å¢åŠ  TPI', () => {
    const wheelchairInput: TPIInput = {
      ...baseInput,
      userAccessibilityNeeds: {
        ...baseInput.userAccessibilityNeeds,
        wheelchair: true
      }
    };

    const normalResult = tpiCalculator.calculate(baseInput);
    const wheelchairResult = tpiCalculator.calculate(wheelchairInput);

    expect(wheelchairResult.score).toBeGreaterThan(normalResult.score);
    expect(wheelchairResult.breakdown.userModifier).toBe(40);
  });

  test('è¡Œææ‡‰å¢åŠ å‚ç›´ç§»å‹•å’Œäººæ½®åˆ†æ•¸', () => {
    const luggageInput: TPIInput = {
      ...baseInput,
      userHasLuggage: true
    };

    const normalResult = tpiCalculator.calculate(baseInput);
    const luggageResult = tpiCalculator.calculate(luggageInput);

    expect(luggageResult.breakdown.vertical).toBeGreaterThan(normalResult.breakdown.vertical);
  });

  test('æ–½å·¥ä¸­æ‡‰å¢åŠ è¤‡é›œåº¦åˆ†æ•¸', () => {
    const constructionInput: TPIInput = {
      ...baseInput,
      transfer: {
        ...baseInput.transfer,
        complexity: {
          ...baseInput.transfer.complexity,
          underConstruction: true
        }
      }
    };

    const normalResult = tpiCalculator.calculate(baseInput);
    const constructionResult = tpiCalculator.calculate(constructionInput);

    expect(constructionResult.breakdown.complexity).toBeGreaterThan(normalResult.breakdown.complexity);
  });
});
```

---

## ğŸ”§ Phase 2: ç³»çµ±å¼·åŒ–èˆ‡æ“´å±• (ä¸­æœŸ - 10å€‹å·¥ä½œå¤©)

### 2.1 éŒ¯èª¤ç›£æ§èˆ‡å‘Šè­¦ç³»çµ±

**ç›®æ¨™**: å»ºç«‹å®Œæ•´çš„éŒ¯èª¤è¿½è¹¤å’Œå‘Šè­¦æ©Ÿåˆ¶

**æª”æ¡ˆ**:
- `src/lib/monitoring/ErrorTracker.ts` (æ–°å»º)
- `src/lib/monitoring/AlertService.ts` (æ–°å»º)

#### ä»»å‹™ 2.1.1: éŒ¯èª¤è¿½è¹¤å™¨

```typescript
// src/lib/monitoring/ErrorTracker.ts

export interface ErrorContext {
  component: string;
  operation: string;
  userId?: string;
  query?: string;
  metadata?: Record<string, unknown>;
}

export interface TrackedError {
  id: string;
  timestamp: Date;
  error: Error;
  context: ErrorContext;
  severity: 'low' | 'medium' | 'high' | 'critical';
  resolved: boolean;
}

export class ErrorTracker {
  private errors: TrackedError[] = [];
  private errorCounts: Map<string, number> = new Map();
  private readonly MAX_ERRORS = 1000;
  private readonly ALERT_THRESHOLD = 10; // 10 æ¬¡ç›¸åŒéŒ¯èª¤è§¸ç™¼å‘Šè­¦

  public track(error: Error, context: ErrorContext): string {
    const errorKey = `${context.component}:${context.operation}:${error.message}`;
    const count = (this.errorCounts.get(errorKey) || 0) + 1;
    this.errorCounts.set(errorKey, count);

    const severity = this.determineSeverity(error, context, count);
    const id = `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const trackedError: TrackedError = {
      id,
      timestamp: new Date(),
      error,
      context,
      severity,
      resolved: false
    };

    this.errors.push(trackedError);

    // ä¿æŒéŒ¯èª¤åˆ—è¡¨åœ¨é™åˆ¶å…§
    if (this.errors.length > this.MAX_ERRORS) {
      this.errors = this.errors.slice(-this.MAX_ERRORS);
    }

    // è¨˜éŒ„åˆ°æ§åˆ¶å°
    this.logError(trackedError);

    // æª¢æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
    if (count >= this.ALERT_THRESHOLD || severity === 'critical') {
      this.triggerAlert(trackedError, count);
    }

    return id;
  }

  private determineSeverity(
    error: Error,
    context: ErrorContext,
    count: number
  ): TrackedError['severity'] {
    // API éŒ¯èª¤
    if (context.component === 'odpt' || context.component === 'weather') {
      if (count >= 5) return 'high';
      return 'medium';
    }

    // è³‡æ–™åº«éŒ¯èª¤
    if (context.component === 'supabase') {
      return 'high';
    }

    // LLM éŒ¯èª¤
    if (context.component === 'llm') {
      if (count >= 10) return 'high';
      return 'medium';
    }

    // ä¸€èˆ¬éŒ¯èª¤
    if (count >= 20) return 'high';
    if (count >= 10) return 'medium';
    return 'low';
  }

  private logError(trackedError: TrackedError): void {
    const { error, context, severity } = trackedError;
    const logPrefix = `[${severity.toUpperCase()}][${context.component}]`;

    console.error(
      `${logPrefix} ${context.operation} failed:`,
      error.message,
      context.metadata ? JSON.stringify(context.metadata) : ''
    );
  }

  private triggerAlert(trackedError: TrackedError, count: number): void {
    // TODO: æ•´åˆå¯¦éš›å‘Šè­¦æœå‹™ (Slack, PagerDuty, etc.)
    console.warn(
      `ğŸš¨ ALERT: ${trackedError.context.component}.${trackedError.context.operation}`,
      `ç™¼ç”Ÿ ${count} æ¬¡`,
      `åš´é‡ç¨‹åº¦: ${trackedError.severity}`
    );
  }

  public getRecentErrors(limit: number = 100): TrackedError[] {
    return this.errors.slice(-limit);
  }

  public getErrorStats(): Record<string, number> {
    return Object.fromEntries(this.errorCounts);
  }

  public clearResolved(): void {
    this.errors = this.errors.filter(e => !e.resolved);
  }
}

export const errorTracker = new ErrorTracker();
```

---

### 2.2 Nearby Amenities æ•¸æ“šæ“´å±•

**ç›®æ¨™**: æ“´å±•è»Šç«™å‘¨é‚Šè¨­æ–½æ•¸æ“šï¼Œæ”¯æ´ WVC è¨ˆç®—

#### ä»»å‹™ 2.2.1: OSM æ•¸æ“šæ•´åˆè…³æœ¬

```typescript
// scripts/import_osm_amenities.ts

import { createClient } from '@supabase/supabase-js';

interface OSMAmenity {
  osm_id: string;
  name: string;
  name_en?: string;
  amenity_type: string;
  lat: number;
  lng: number;
  tags: Record<string, string>;
}

const AMENITY_MAPPING: Record<string, string> = {
  cafe: 'cafe',
  restaurant: 'restaurant',
  fast_food: 'restaurant',
  convenience: 'convenience_store',
  internet_cafe: 'internet_cafe',
  waiting_room: 'rest_area'
};

async function importOSMAmenities(stationId: string, lat: number, lng: number, radiusMeters: number = 500) {
  // Overpass API æŸ¥è©¢
  const query = `
    [out:json][timeout:25];
    (
      node["amenity"~"cafe|restaurant|fast_food"](around:${radiusMeters},${lat},${lng});
      node["shop"="convenience"](around:${radiusMeters},${lat},${lng});
    );
    out body;
  `;

  const response = await fetch('https://overpass-api.de/api/interpreter', {
    method: 'POST',
    body: query
  });

  const data = await response.json();

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_KEY!
  );

  for (const element of data.elements) {
    const amenityType = AMENITY_MAPPING[element.tags.amenity] ||
                        AMENITY_MAPPING[element.tags.shop] ||
                        'other';

    if (amenityType === 'other') continue;

    // è¨ˆç®—æ­¥è¡Œæ™‚é–“ (å‡è¨­æ­¥è¡Œé€Ÿåº¦ 80m/min)
    const distance = calculateDistance(lat, lng, element.lat, element.lon);
    const walkMinutes = Math.ceil(distance / 80);

    const amenity = {
      station_id: stationId,
      amenity_type: amenityType,
      name: element.tags.name || element.tags['name:ja'] || 'ä¸æ˜',
      name_en: element.tags['name:en'] || null,
      walk_minutes: walkMinutes,
      lat: element.lat,
      lng: element.lon,
      has_seating: amenityType === 'cafe' || amenityType === 'restaurant',
      has_wifi: element.tags.internet_access === 'wlan' || element.tags.wifi === 'yes',
      has_power_outlet: element.tags.power_outlet === 'yes',
      vibe_tags: extractVibeTags(element.tags),
      osm_id: element.id.toString()
    };

    await supabase
      .from('station_nearby_amenities')
      .upsert(amenity, { onConflict: 'station_id,osm_id' });
  }
}

function calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
  const R = 6371000; // åœ°çƒåŠå¾‘ (å…¬å°º)
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function extractVibeTags(tags: Record<string, string>): string[] {
  const vibeTags: string[] = [];

  if (tags.cuisine) {
    vibeTags.push(`CUISINE_${tags.cuisine.toUpperCase()}`);
  }
  if (tags.outdoor_seating === 'yes') {
    vibeTags.push('OUTDOOR_SEATING');
  }
  if (tags['diet:vegan'] === 'yes' || tags['diet:vegetarian'] === 'yes') {
    vibeTags.push('HEALTHY');
  }
  if (tags.smoking === 'no') {
    vibeTags.push('NON_SMOKING');
  }

  return vibeTags;
}
```

---

### 2.3 Deep Link æ•´åˆ

**ç›®æ¨™**: æ•´åˆè¨ˆç¨‹è»Šå’Œé¤å»³é è¨‚çš„ Deep Link

```typescript
// src/lib/services/DeepLinkService.ts

export interface DeepLinkOptions {
  destination?: { lat: number; lng: number; name?: string };
  origin?: { lat: number; lng: number };
  restaurantId?: string;
  locale?: string;
}

export class DeepLinkService {
  /**
   * ç”Ÿæˆè¨ˆç¨‹è»Š App Deep Link
   */
  public static getTaxiDeepLink(
    provider: 'go' | 'japantaxi' | 'uber' | 's_ride',
    options: DeepLinkOptions
  ): string {
    const { destination, origin } = options;

    switch (provider) {
      case 'go':
        // GO ã‚¿ã‚¯ã‚·ãƒ¼
        if (destination) {
          return `gojp://ride?dest_lat=${destination.lat}&dest_lng=${destination.lng}&dest_name=${encodeURIComponent(destination.name || '')}`;
        }
        return 'https://go.mo-t.com/';

      case 'japantaxi':
        // JapanTaxi
        if (destination) {
          return `japantaxi://ride?to_lat=${destination.lat}&to_lon=${destination.lng}`;
        }
        return 'https://japantaxi.jp/';

      case 'uber':
        // Uber
        if (destination && origin) {
          return `uber://?action=setPickup&pickup[latitude]=${origin.lat}&pickup[longitude]=${origin.lng}&dropoff[latitude]=${destination.lat}&dropoff[longitude]=${destination.lng}`;
        }
        return 'https://m.uber.com/';

      case 's_ride':
        // S.RIDE
        return 'https://www.sride.jp/';

      default:
        return 'https://go.mo-t.com/';
    }
  }

  /**
   * ç”Ÿæˆé¤å»³é è¨‚ Deep Link
   */
  public static getRestaurantDeepLink(
    provider: 'tabelog' | 'hotpepper' | 'gurunavi',
    options: DeepLinkOptions
  ): string {
    const { restaurantId, locale } = options;

    switch (provider) {
      case 'tabelog':
        if (restaurantId) {
          const lang = locale?.startsWith('en') ? 'en' : locale?.startsWith('zh') ? 'cn' : '';
          return `https://tabelog.com/${lang ? lang + '/' : ''}${restaurantId}/`;
        }
        return 'https://tabelog.com/';

      case 'hotpepper':
        if (restaurantId) {
          return `https://www.hotpepper.jp/str${restaurantId}/`;
        }
        return 'https://www.hotpepper.jp/';

      case 'gurunavi':
        if (restaurantId) {
          const lang = locale?.startsWith('en') ? 'en' : locale?.startsWith('zh') ? 'cn' : 'jp';
          return `https://gurunavi.com/${lang}/r${restaurantId}/`;
        }
        return 'https://gurunavi.com/';

      default:
        return 'https://tabelog.com/';
    }
  }

  /**
   * æ ¹æ“šç”¨æˆ¶å¹³å°é¸æ“‡æœ€ä½³è¨ˆç¨‹è»Šæœå‹™
   */
  public static getBestTaxiApp(userLocation: { lat: number; lng: number }): {
    provider: 'go' | 'japantaxi' | 'uber' | 's_ride';
    reason: string;
  } {
    // æ±äº¬ 23 å€ä¸»è¦ä½¿ç”¨ GO
    // å…¶ä»–åœ°å€å„ªå…ˆ JapanTaxi
    const isTokyoCore =
      userLocation.lat >= 35.6 && userLocation.lat <= 35.8 &&
      userLocation.lng >= 139.6 && userLocation.lng <= 139.9;

    if (isTokyoCore) {
      return { provider: 'go', reason: 'æ±äº¬å¸‚å€ GO è»Šè¼›æœ€å¤š' };
    }
    return { provider: 'japantaxi', reason: 'å…¨åœ‹ç¯„åœ JapanTaxi è¦†è“‹è¼ƒå»£' };
  }
}
```

---

### 2.4 å®Œæ•´æ¸¬è©¦å¥—ä»¶

**ç›®æ¨™**: å»ºç«‹æ•´åˆæ¸¬è©¦å’Œç«¯å°ç«¯æ¸¬è©¦

```typescript
// src/lib/l4/__tests__/HybridEngine.integration.test.ts

import { hybridEngine } from '../HybridEngine';

describe('HybridEngine Integration Tests', () => {
  describe('è·¯ç·šæŸ¥è©¢', () => {
    test('æ‡‰è©²è¿”å›å¸¶æœ‰ TPI è©•åˆ†çš„è·¯ç·š', async () => {
      const response = await hybridEngine.processRequest({
        text: 'å¾æ±äº¬ç«™åˆ°æ–°å®¿æ€éº¼èµ°ï¼Ÿ',
        locale: 'zh-TW',
        context: {}
      });

      expect(response).not.toBeNull();
      expect(response?.source).toBe('algorithm');
      expect(response?.type).toBe('route');
      expect(response?.data?.routes).toBeDefined();

      // é©—è­‰è·¯ç·šæœ‰ TPI è©•åˆ†
      if (response?.data?.routes?.length > 0) {
        expect(response.data.routes[0].tpiScore).toBeDefined();
      }
    });

    test('å»¶èª¤æƒ…æ³ä¸‹æ‡‰è©²è€ƒæ…® CDR', async () => {
      // æ¨¡æ“¬ä¸­å¤®ç·šå»¶èª¤
      const response = await hybridEngine.processRequest({
        text: 'æ±äº¬ç«™åˆ°æ–°å®¿ï¼Œä¸­å¤®ç·šå¥½åƒå»¶èª¤äº†',
        locale: 'zh-TW',
        context: {}
      });

      expect(response).not.toBeNull();
      // æ‡‰è©²å»ºè­°æ›¿ä»£è·¯ç·šæˆ–è­¦å‘Šé¢¨éšª
    });
  });

  describe('å¤©æ°£è­¦å ±', () => {
    test('æ‡‰è©²éæ¿¾éç›®æ¨™å€åŸŸçš„è­¦å ±', async () => {
      // æ¸¬è©¦ä¼Šè±†è«¸å³¶è­¦å ±ä¸æ‡‰è§¸ç™¼
      // ...
    });
  });

  describe('WVC å»ºè­°', () => {
    test('é•·æ™‚é–“ç­‰å¾…æ‡‰å»ºè­°é™„è¿‘ä¼‘æ¯', async () => {
      // ...
    });
  });
});
```

---

## ğŸ“ˆ Phase 3: æŒçºŒå„ªåŒ– (é•·æœŸ)

### 3.1 ç”¨æˆ¶åé¥‹å­¸ç¿’ç³»çµ±

```typescript
// src/lib/learning/FeedbackLearner.ts

export interface UserFeedback {
  sessionId: string;
  queryId: string;
  rating: 1 | 2 | 3 | 4 | 5;
  feedbackType: 'route_quality' | 'timing_accuracy' | 'recommendation_relevance';
  comment?: string;
  context: {
    query: string;
    response: any;
    actualOutcome?: string;
  };
}

export class FeedbackLearner {
  /**
   * æ”¶é›†ç”¨æˆ¶åé¥‹
   */
  public async collectFeedback(feedback: UserFeedback): Promise<void> {
    // å„²å­˜åˆ°è³‡æ–™åº«
    // åˆ†ææ¨¡å¼
    // èª¿æ•´æ¬Šé‡
  }

  /**
   * æ ¹æ“šåé¥‹èª¿æ•´ TPI æ¬Šé‡
   */
  public async adjustTPIWeights(): Promise<void> {
    // åˆ†æç”¨æˆ¶å°è½‰ä¹˜å»ºè­°çš„æ»¿æ„åº¦
    // å¦‚æœç”¨æˆ¶ç¶“å¸¸æŠ±æ€¨ã€Œæ¯”é æœŸè¾›è‹¦ã€ï¼Œæé«˜ç›¸é—œæ¬Šé‡
  }

  /**
   * æ ¹æ“šåé¥‹èª¿æ•´ WVC é–¾å€¼
   */
  public async adjustWVCThresholds(): Promise<void> {
    // åˆ†æç”¨æˆ¶å°ã€Œç­‰å¾…/æ”¾æ£„ã€å»ºè­°çš„åé¥‹
  }
}
```

### 3.2 A/B æ¸¬è©¦æ¡†æ¶

```typescript
// src/lib/experiments/ABTestFramework.ts

export interface Experiment {
  id: string;
  name: string;
  description: string;
  variants: {
    id: string;
    name: string;
    weight: number; // 0-100
    config: Record<string, unknown>;
  }[];
  startDate: Date;
  endDate?: Date;
  targetAudience?: {
    locale?: string[];
    userType?: string[];
  };
}

export class ABTestFramework {
  private experiments: Map<string, Experiment> = new Map();

  /**
   * åˆ†é…ç”¨æˆ¶åˆ°å¯¦é©—çµ„
   */
  public assignVariant(experimentId: string, userId: string): string {
    const experiment = this.experiments.get(experimentId);
    if (!experiment) return 'control';

    // ä½¿ç”¨ç”¨æˆ¶ ID çš„ hash ç¢ºä¿ä¸€è‡´æ€§
    const hash = this.hashUserId(userId);
    let cumulative = 0;

    for (const variant of experiment.variants) {
      cumulative += variant.weight;
      if (hash < cumulative) {
        return variant.id;
      }
    }

    return experiment.variants[0].id;
  }

  /**
   * è¨˜éŒ„å¯¦é©—çµæœ
   */
  public async recordMetric(
    experimentId: string,
    variantId: string,
    metricName: string,
    value: number
  ): Promise<void> {
    // å„²å­˜åˆ°åˆ†æè³‡æ–™åº«
  }

  private hashUserId(userId: string): number {
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = ((hash << 5) - hash) + userId.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash) % 100;
  }
}
```

---

## ğŸ“… å·¥ä½œæ™‚ç¨‹ç¸½è¦½

```
Week 1 (Phase 1)
â”œâ”€â”€ Day 1-2: TPI è¨ˆç®—å™¨å¯¦ç¾ + å–®å…ƒæ¸¬è©¦
â”œâ”€â”€ Day 3: CDR è¨ˆç®—å™¨å¯¦ç¾ + å–®å…ƒæ¸¬è©¦
â”œâ”€â”€ Day 4: HybridEngine æ•´åˆ
â””â”€â”€ Day 5: TOP 10 ç«™é»æ•¸æ“šå¡«å…… + æ¸¬è©¦

Week 2-3 (Phase 2)
â”œâ”€â”€ Day 1-2: éŒ¯èª¤ç›£æ§ç³»çµ±
â”œâ”€â”€ Day 3-4: OSM Amenities æ•¸æ“šæ•´åˆ
â”œâ”€â”€ Day 5-6: Deep Link æœå‹™æ•´åˆ
â”œâ”€â”€ Day 7-8: å®Œæ•´æ¸¬è©¦å¥—ä»¶
â””â”€â”€ Day 9-10: æ•ˆèƒ½å„ªåŒ– + æ–‡æª”æ›´æ–°

Week 4+ (Phase 3)
â”œâ”€â”€ ç”¨æˆ¶åé¥‹æ”¶é›†ç³»çµ±
â”œâ”€â”€ A/B æ¸¬è©¦æ¡†æ¶
â”œâ”€â”€ æ¬Šé‡è‡ªå‹•èª¿å„ª
â””â”€â”€ æŒçºŒç›£æ§èˆ‡è¿­ä»£
```

---

## âœ… å®Œæˆæ¨™æº– (Definition of Done)

### Phase 1
- [ ] TPI è¨ˆç®—å™¨é€šéæ‰€æœ‰å–®å…ƒæ¸¬è©¦
- [ ] CDR è¨ˆç®—å™¨é€šéæ‰€æœ‰å–®å…ƒæ¸¬è©¦
- [ ] HybridEngine è·¯ç·šæ¨è–¦åŒ…å« TPI/CDR è©•åˆ†
- [ ] TOP 10 ç«™é»è½‰ä¹˜æ•¸æ“šå·²å¡«å……
- [ ] æ–‡æª”å·²æ›´æ–°

### Phase 2
- [ ] éŒ¯èª¤ç›£æ§ç³»çµ±ä¸Šç·š
- [ ] Amenities æ•¸æ“šè¦†è“‹ 50+ ç«™é»
- [ ] Deep Link æ•´åˆ GO/JapanTaxi
- [ ] æ•´åˆæ¸¬è©¦è¦†è“‹ç‡ > 80%
- [ ] æ•ˆèƒ½åŸºæº–æ¸¬è©¦é€šé

### Phase 3
- [ ] åé¥‹æ”¶é›†ç³»çµ±ä¸Šç·š
- [ ] A/B æ¸¬è©¦æ¡†æ¶å¯ç”¨
- [ ] ç¬¬ä¸€è¼ªæ¬Šé‡å„ªåŒ–å®Œæˆ

---

## ğŸ”— ç›¸é—œæ–‡æª”

- [Agent Reasoning Chain è¨­è¨ˆæ–‡æª”](./AGENT_REASONING_CHAIN_DESIGN.md)
- [ODPT Challenge 2025 æäº¤æ–‡æª”](./ODPT_CHALLENGE_2025_SUBMISSION.md)
- [Agent Framework è©•ä¼°å ±å‘Š](./AGENT_FRAMEWORK_EVALUATION.md)

---

*æ–‡æª”ç‰ˆæœ¬: 1.0*
*æœ€å¾Œæ›´æ–°: 2025-01-09*
